\section{Lock-Free Algorithm}
\subsection{Overview}
Every operation in our algorithm begins with a seek phase. 
\subsubsection{Seek:} The operation traverses the search tree from the root node until it finds the target key or if it reaches a non-binary node. We refer to the path traversed by the operation in the seek phase as the \accesspath \space and the last node in the \accesspath \space is referred to as \terminalnode. The operation then compares the target key with the value stored in the \terminalnode. Depending on the result of the comparison and the type of the operation, the operation either terminates or moves to the next phase. In certain cases in which a key may have moved upward along the \accesspath, the seek operation may have to restart (will be discussed later). We now describe the next steps for each of the type of operation one-by-one.
\subsubsection{Search:} A search operation invokes seek and returns \True \space if the stored key matches the target key; otherwise it returns \False.
\subsubsection{Insert:} An insert operation invokes seek and returns \False \space if the key in the \terminalnode \space matches the target key; otherwise it moves to the execution phase. In the execution phase, it attempts to insert the key into the tree as a child node of the last node in the \accesspath \space using a CAS instruction. If the instruction succeeds, then the operation returns \True; otherwise, it restarts from the seek phase after possibly helping.
\subsubsection{Delete:} A delete operation invokes seek and returns \False \space if the stored key does not match the target key; otherwise it moves to the execution phase. In the execution phase, it attempts to remove the key stored in the \terminalnode \space of the \accesspath. There are two cases depending on if the \terminalnode \space is a binary node (has two children) or not (at most one child). In the first case, the operation is referred to as \textit{complex} delete. In the second case, it is referred to as \textit{simple} delete. In the case of \textit{simple} delete (as shown in Fig.~\ref{fig:simple}), the \terminalnode \space is removed by changing the pointer at the parent of the \terminalnode. In the case of \textit{complex} delete (as shown in Fig.~\ref{fig:complex}), the key to be deleted is replaced with the next largest key in the tree (which will be stored in the leftmost node of the right subtree of the \terminalnode). 

\subsection{Details of the Algorithm}
\input{pseudocode/structures}
We use sentinel keys and nodes to handle the boundary cases easily. A tree node in our algorithm consists of three fields: (i) \markAndKey \space which contains the key stored in the node, (ii) \child \space array, which contains the addresses of the left and right children and (iii) \readyToReplace, which is a boolean flag used by \textit{complex} delete operation to indicate if a node can be replaced with a fresh copy of it. \par
This algorithm like the algorithm described by Natarajan and Mittal~\cite{Natarajan:2014:PPOPP}, operates on edge level. A delete operation obtains ownership of the edges it needs to work on by marking them. To enable marking we steal two bits from the child addresses of a node. To avoid ABA problem, as in Howley and Jones~\cite{HowJon:2012:SPAA}, we steal another bit from the child address referred to as \nullFlag \space and use it to indicate whether the address points to a null or a non-null value. So when an address changes from a non-null value to a null value, we only set the \nullFlag \space and the contents of the address are not modified. As \textit{complex} delete replaces a key in a node being deleted, a flag is required to identify if the key in a node has changed. So we steal a bit from the key field and use it as a mark bit. If the mark bit is set, it denotes that the key in the node has changed.

We next describe the details of the seek phase, which is executed by all operations (search as well as modify) after which we describe the details of the execution phases of insert and delete operations.

\subsubsection{The Seek Phase} \paragraph{}
\input{Figures/initialTree}
\input{pseudocode/seek}
\input{pseudocode/search}
A seek operation keeps track of the node in the \accesspath \space at which the last "right turn" was taken (i.e., right edge was followed). Let us call this node as \anchorNode. Upon reaching the last node, it compares the stored key with the target key. If they do not match, then it is possible that the key may have moved up in the tree. So key stored in the \anchorNode \space is checked to see if has changed. If the key has changed then the seek operation restarts. If the key has not changed, then the key stored in the \anchorNode \space is checked to see if it is undergoing deletion (by checking if its left child edge is marked). If the key is not undergoing deletion, then the seek operation terminates. If the key is undergoing deletion, then it checks if the \anchorNode \space of the current traversal matches with the \anchorNode \space of the previous traversal. If they match, then the seek operation terminates by returning the results of the previous traversal; otherwise it restarts.\par
In the case of insert operation, the seek operation also returns the injection point which is the current contents of the child location at which the insert will occur.

\subsubsection{Execution Phase of an Insert Operation} \paragraph{}
\input{pseudocode/insert}
In the execution phase, an insert operation creates a new node containing the target key. It then adds the new node to the tree at the injection point using a CAS instruction. If the CAS succeeds, then (the new node becomes a part of the tree and) the operation terminates; otherwise, the operation determines if it failed because of a conflicting delete operation in progress. If there is no conflicting delete operation in progress then the operation restarts from the seek phase; otherwise it performs helping (which will be described later) and then restarts from the seek phase.

\subsubsection{Execution Phase of a Delete Operation} \paragraph{}
\input{Figures/delete}
The execution of a delete operation starts in the \textit{injection} mode. Once the operation has been injected into the tree, then it advances to the \textit{cleanup} mode.
\input{pseudocode/delete}
\subsubsection{Injection Mode:} In the \textit{injection} mode, the delete operation marks the left child edge of the target node using a CAS instruction. If the CAS instruction succeeds, then the delete operation has been injected into the tree and is guaranteed to complete. Then the operation moves on to the \textit{cleanup} mode. But if the CAS instruction fails, the operation performs helping and restarts from the seek phase (and stays in the \textit{injection} mode).
\input{pseudocode/inject}
\subsubsection{Cleanup Mode:} In the \textit{cleanup} mode, the operation begins by marking the right child edge of the target node using a BTS (Bit Test and Set) instruction (this can also be done using a CAS instruction as well). Note that we maintain an invariant that edges which are once marked cannot be unmarked. Eventually the node is either removed from the tree (by \textit{simple} delete) or replaced with a "new" node containing the next largest key (by \textit{complex} delete). Further, a marked edge is changed only under a specific situation by a delete operation as part of helping (described later). \par
\input{pseudocode/cleanup}
After marking both the edges, an operation checks whether the node is a binary node or not. If it is a binary node, then the delete operation is classified as a \textit{complex} delete; otherwise it is classified as a \textit{simple} delete. Let $T$ be the \terminalnode, $T.parent$ be its parent node and $T.left$ and $T.right$ be the left and right child node respectively, of $T$. We now discuss the two types of delete operation.
\subsubsection{Simple Delete:}
	In this case, either $T.left$ or $T.right$ is a null node. Note that both $T.left$ and $T.right$ may be null nodes in which case $T$ will be a leaf node. Without loss of generality, assume that $T.right$ is a null node. Delete operation attempts to change the pointer at $T.parent$ that is pointing to $T$ to point to $T.left$ using a CAS instruction. If the CAS instruction succeeds, then the operation terminates; otherwise, the delete operation performs another seek operation. If the seek operation either fails to find the target key or returns a \terminalnode \space different from $T$, then $T$ has been already removed from the tree (by another operation as part of helping) and the operation terminates; otherwise, it attempts to remove $T$ from the tree again. Note that the new seek operation may return a different parent node. This process may be repeated multiple times.
\input{pseudocode/findAndMarkSuccessor}
\input{pseudocode/removeSuccessor}
\subsubsection{Complex Delete:} In this case, both $T.left$ and $T.right$ are non-null nodes. The operation now performs the following steps:
\begin{enumerate}
\item Locate the next largest key in the tree, which is the smallest key in the subtree rooted at the right child of the \terminalnode \space $T$. We refer to this key as the \textit{successor key} and the node storing this key as the \textit{successor node}. Let $S$ denote the \textit{successor node} and $S.parent$ denote its parent node.
\item Claim the \textit{successor node}. This involves marking both the child edges of $S$. Note that the left edge of $S$ will be null. To distinguish between marking a \terminalnode \space (for deletion) and marking a \textit{successor node} (for promotion), we steal two bits from the address and refer to them as \deleteFlag \space and \promoteFlag \space respectively. The left edge of $S$ is marked (i.e., \promoteFlag \space is set) using a CAS instruction. As part of marking the left edge, we also store the address of the \terminalnode \space $T$ in the left edge. This is done to enable helping in case the \textit{successor node} is obstructing the progress of another operation. In case if the CAS instruction fails, the operation repeats from step 1. The right edge of $S$ is marked using a BTS instruction.
\item Promote the \textit{successor key}. The \textit{successor key} is copied into the \terminalnode. At the same time, the mark bit in the key is set to indicate that the key currently stored in the \terminalnode \space is the \textit{successor key} and not the target key.
\item The \textit{successor node} $S$ is deleted by changing the pointer at $S.parent$ that is pointing to $S$ to point to the right child of $S$ using a CAS instruction. If the CAS instruction fails, then the operation performs helping if needed. It then finds the \textit{successor node} again by performing a traversal starting from the right child of the \terminalnode \space $T$ and repeats step 4. If the \textit{successor node} is not found in the traversal, then it has been already removed from the tree ( by another operation as part of helping) and the operation moves to step 5. 
\item Note that, at this point, the original key in the \terminalnode \space has been replaced with the \textit{successor key}. Further, its key as well as both its edges are marked. The \terminalnode \space is now replaced with a new node whose contents are same as that of the \terminalnode \space expect that all the fields are unmarked. The \terminalnode \space is then replaced with a new node using a CAS instruction at the parent node. If the CAS instruction succeeds, then the operation terminates; otherwise, as in the case of \textit{simple} delete, it performs another seek operation, this time looking for the \textit{successor key}. If the seek operation either fails to find the \textit{successor key} or returns a \terminalnode \space different from $T$, then $T$ has been already replaced (by another operation as part of helping) and the operation terminates. On the other hand if the seek operation finds the \terminalnode \space $T$ with the \textit{successor key}, it attempts to replace $T$ again. Note that the new seek operation may return a different parent node. This process may be repeated multiple times.
\end{enumerate}
\input{pseudocode/findSmallest}
\input{pseudocode/updateModeAndType}
\subsubsection{Helping} \paragraph{}
To enable helping, whenever traversing the tree to locate either a target key or a \textit{successor key}, we keep track of the last unmarked edge encountered in the traversal. Whenever an operation fails while executing a CAS instruction, it helps the operation in progress at the child end of the unmarked edge if different from its own operation. Note that, when traversing the tree looking for a target key, the last unmarked edge will always be found because of the sentinel keys. However, when traversing the tree looking for a \textit{successor key}, the last unmarked edge may not always exist since the traversal starts from the middle of the tree from the right child of a \terminalnode. Recall that $T$ denotes a \terminalnode \space and $T.right$ its right child node. If no unmarked edge is found during the traversal from $T.right$, then helping is performed along the edge ($T$,$T.right$),that is, the delete operation in progress at $T.right$ is helped. This will involve modifying the edge ($T$,$T.right$) even though the edge is marked to either remove $T.right$ (if \textit{simple} delete) or replace $T.right$ with a fresh node (if \textit{complex} delete).