\section{Lock-Free Algorithm}
Every operation in our algorithm begins with a seek phase. 
\subsection{Overview}
\subsubsection{Seek:} The operation traverses the search tree from the root node until it finds the target key or it reaches a leaf node. We refer to the path traversed by the operation in the seek phase as the access path. The operation then compares the target key with the value stored in node. Depending on the result of the comparison and the type of the operation, the operation either terminates or moves to the next phase. For certain cases where some key may have moved up the tree, the seek operation may have to restart (will be discussed later). We now describe the next steps for each of the type of operation one-by-one.
\subsubsection{Search:} A search operation invokes seek and returns \textit{true} if the stored key matches the target key; otherwise it returns \textit{false}.
\subsubsection{Insert:} An insert operation invokes seek and returns \textit{false} if the stored key matches the target key; otherwise it moves to the execution phase. In the execution phase, it attempts to insert the key into the tree as a child node of the last node in the access-path using a CAS instruction. If the instruction succeeds, then the operation returns \textit{true}; otherwise, it restarts from the seek phase after possibly helping.
\subsubsection{Delete:} A delete operation invokes seek and returns \textit{false} if the stored key does not match the target key; otherwise it moves to the execution phase. In the execution phase, it attempts to remove the key stored in the last node in the access path. let the last node be referred to as \textit{target node}. There are two cases depending on if the \textit{target node} is a binary node (has two children) or not (at most one child). In the first case, the operation is referred to as complex delete. In the second case, it is referred to as simple delete. In the case of simple delete (as shown in Fig.~\ref{fig:simple}), the target node is removed by changing the pointer at the parent of the \textit{target node}. In the case of complex delete (as shown in Fig.~\ref{fig:complex}), the key to be deleted is replaced with the next largest key in the tree (which will be stored in the leftmost node of the right subtree of the \textit{target node}). 

\input{Figures/delete}

\subsection{Details of the Algorithm}
We use sentinel keys and nodes to handle the boundary cases easily. A tree node in our algorithm consists of three fields: (i) $\markAndKey$ which contains the key stored in the node, (ii) $\child$ array, which contains the addresses of the left and right children and (iii) $\readyToReplace$, which is a boolean flag used by complex delete operation to indicate if a node can be replaced with a fresh copy of it. \par
This algorithm like the algorithm described by Natarajan and Mittal~\cite{Natarajan:2014:PPOPP}, operates on edge level. A delete operation obtains ownership of the edges it needs to work on by marking them. To enable marking we steal two bits from the child addresses of a node. To avoid ABA problem, as in Howley and Jones~\cite{HowJon:2012:SPAA}, we steal another bit from the child address referred to as $\nullFlag$ and use it to indicate whether the address points to a null or a non-null value. So when an address changes from a non-null value to a null value, we only set the $\nullFlag$ and the contents of the address are not modified. As complex delete replaces a key in a node being deleted, a flag is required to identify if the key in a node has changed. So we steal a bit from the key field and use it as a mark bit. If the mark bit is set, it denotes that the key in the node has changed.

We next describe the details of the seek phase, which is executed by all operations (search as well as modify) after which we describe the details of the execution phases of insert and delete operations.

\subsubsection{The Seek Phase} \paragraph{}
A seek operation keeps track of the node in the access path at which the last "right turn" was taken (i.e., right edge was followed). Let us call this node as $\anchorNode$. Upon reaching the last node, it compares the stored key with the target key. If they do not match, then it is possible that the key may have moved up in the tree. So key stored in the $\anchorNode$ is checked to see if has changed. If the key has changed then the seek operation restarts. If the key has not changed, then the key stored in the $\anchorNode$ is checked to see if it is undergoing deletion (by checking if its left child edge is marked). If the key is not undergoing deletion, then the seek operation terminates. If the key is undergoing deletion, then it checks if the $\anchorNode$ of the current traversal matches with the $\anchorNode$ of the previous traversal. If they match, then the seek operation terminates by returning the results of the previous traversal; otherwise it restarts.\par
In the case of insert operation, the seek operation also returns the injection point which is the current contents of the child location at which the insert will occur.

\subsubsection{Execution Phase of an Insert Operation} \paragraph{}
In the execution phase, an insert operation creates a new node containing the target key. It then adds the new node to the tree at the injection point using a CAS instruction. If the CAS succeeds, then (the new node becomes a part of the tree and) the operation terminates; otherwise, the operation determines if it failed because of a conflicting delete operation in progress. If there is no conflicting delete operation in progress then the operation restarts from the seek phase; otherwise it performs helping (which will be described later) and then restarts from the seek phase.

\subsubsection{Execution Phase of a Delete Operation} \paragraph{}
The execution of a delete operation starts in the \textit{injection} mode. Once the operation has been injected into the tree, then it advances to the \textit{cleanup} mode.
\subsubsection{Injection Mode:} In the injection mode, the delete operation marks the left child edge of the target node using a CAS instruction. If the CAS instruction succeeds, then the delete operation has been injected into the tree and is guaranteed to complete. Then the operation moves on to the \textit{cleanup} mode. But if the CAS instruction fails, the operation performs helping and restarts from the seek phase (and stays in the injection mode).

\subsubsection{Cleanup Mode:} In the \textit{cleanup} mode, the operation begins by marking the right child edge of the target node using a BTS (Bit Test and Set) instruction (this can also be done using a CAS instruction as well). Note that we maintain an invariant that edges which are once marked cannot be unmarked. Eventually the node is either removed from the tree (by simple delete) or replaced with a "new" node containing the next largest key (by complex delete). Further, a marked edge is changed only under a specific situation by a delete operation as part of helping (described later). \par

After marking both the edges, an operation checks whether the node is a binary node or not. If it is a binary node, then the delete operation is classified as a complex delete; otherwise it is classified as a simple delete. Let \textbf{A} be the target node, $B$ be its parent node and $C$ and $D$ be the left and right child node respectively, of $A$. We now discuss the two types of delete operation.
\subsubsection{Simple Delete:}
	In this case, either $C$ or $D$ is a null node. Note that both $C$ and $D$ may be null nodes in which case $A$ will be a leaf node. Without loss of generality, assume that $D$ is a null node. Delete operation attempts to change the pointer at $B$ that is pointing to $A$ to point to $C$ using a CAS instruction. If the CAS instruction succeeds, then the operation terminates; otherwise, the delete operation performs another seek operation. If the seek operation either fails to find the target key or return a target node different from $A$, then $A$ has been already removed from the tree (by another operation as part of helping) and the operation terminates; otherwise, it attempts to remove $A$ from the tree again. Note that the new seek operation may return a different parent node. This process may be repeated multiple times.
\subsubsection{Complex Delete:} In this case, both $C$ and $D$ are non-null nodes. The operation now performs the following steps:
\begin{enumerate}
\item Locate the next largest key in the tree, which is the smallest key in the subtree rooted at the right child of the target node $A$. We refer to this key as the successor key and the node storing this key as the successor node. Let $S$ denote the successor node and $T$ denote its parent node.
\item Claim the successor node. This involves marking both the child edges of $S$. Note that the left edge of $S$ will be null. To distinguish between marking a target node (for deletion) and marking a successor node (for promotion), we steal two bits from the address and refer to them as $\deleteFlag$ and $\promoteFlag$. The left edge of $S$ is marked (i.e., $\promoteFlag$ is set) using a CAS instruction. As part of marking the left edge, we also store the address of the target node $A$ in the left edge. This is done to enable helping in case the successor node is obstructing the progress of another operation. In case if the CAS instruction fails, the operation repeats from step 1. The right edge of $S$ is marked using a BTS instruction.
\item Promote the successor Key. The successor key is copied into the target node. At the same time, the mark bit in the key is set to indicate that the key currently stored in the target node is the successor key and not the target key.
\item The successor node $S$ is deleted by changing the pointer at $T$ that is pointing to $S$ to point to the right child of $S$ using a CAS instruction. If the CAS instruction fails, then the operation performs helping if needed. It then finds the successor node again by performing a traversal starting from the right child of the target node $A$ and repeats step 4. If the successor node is not found in the traversal, then it has been already removed from the tree ( by another operation as part of helping) and the operation moves to step 5. 
\item Note that, at this point, the original key in the target node has been replaced with the successor key. Further, the key as well as both its edges are marked. The target node is now replaced with a new node whose contents are same as that of the target node expect that all the fields are unmarked. The target node is then replaced with a new node using a CAS instruction at the parent node. If the CAS instruction succeeds, then the operation terminates; otherwise, as in the case of simple delete, it performs another seek operation, this time looking for the successor key. If the seek operation either fails to find the successor key or returns a target node different from $A$, then $A$ has been already replaced (by another operation as part of helping) and the operation terminates. On the other hand if the seek operation finds the target node $A$ with the successor key, it attempts to replace $A$ again. Note that the new seek operation may return a different parent node. This process may be repeated multiple times.
\end{enumerate}

\subsubsection{Helping} \paragraph{}
To enable helping, whenever traversing the tree to locate either a target key or a successor key, we keep track of the last unmarked edge encountered in the traversal. Whenever an operation fails while executing a CAS instruction, it helps the operation in progress at the child end of the unmarked edge if different from its own operation. Note that, when traversing the tree looking for a target key, the last unmarked edge will always be found because of the sentinel keys. However, when traversing the tree looking for a successor key, the last unmarked edge may not always exist since the traversal starts from the middle of the tree from the right child of a target node. Recall that $A$ denotes a target node and $D$ its right child node.If no unmarked edge is found during the traversal from $D$, then helping is performed along the edge ($A$,$D$) under the following conditions (i) delete operation at $D$ is of type simple delete, or (ii) delete operation at $D$ is of type complex delete and is currently at its last step (replacing the target node with a new node).